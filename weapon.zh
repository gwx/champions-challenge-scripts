// Object type used for created weapons.
const int WEAPON_OBJECT_TYPE = 31;

////////////////////////////////////////////////////////////////
// Data Array

// Maximum number of weapons.
const int WEAPON_DATA_COUNT = 510;
// Space allocated for each weapon.
const int WEAPON_DATA_SIZE = 20;
// All weapon data.
int Weapon_Data[10200]; // size is previous two multiplied

//// First flag group.
const int WEAPON_F1 = 0;
// If this weapon slot has been allocated.
const int WEAPON_F1_ALLOC     = 0001b;
// Set if the weapon can hurt link
const int WEAPON_F1_HIT_LINK  = 0010b;
// Set if the weapon can hurt enemies
const int WEAPON_F1_HIT_ENEMY = 0100b;
// If the weapon can cut grass.
const int WEAPON_F1_CUT       = 1000b;

// Index for the id of the weapon's corresponding object.
// If it uses an eweapon, add LWEAPON_MAX to it.
const int WEAPON_OBJECT_ID = 1;

// Index for weapon damage.
const int WEAPON_DAMAGE = 2;

// Indices for the weapon's position
const int WEAPON_BOUNDS = 3;
const int WEAPON_BOUND_UP = 3;
const int WEAPON_BOUND_DOWN = 4;
const int WEAPON_BOUND_LEFT = 5;
const int WEAPON_BOUND_RIGHT = 6;

////////////////////////////////////////////////////////////////
// Basic Accessors

int Weapon_Val(int id, int index) {
	return Weapon_Data[id * WEAPON_DATA_SIZE + index];}

void Weapon_Val(int id, int index, int value) {
	Weapon_Data[id * WEAPON_DATA_SIZE + index] = value;}

bool Weapon_Flag(int id, int index, int key) {
	return Weapon_Val(id, index) & key;}

void Weapon_Flag(int id, int index, int key, bool value) {
	int flagset = Weapon_Val(id, index);
	if (value) {flagset |= key;}
	else {flagset &= ~key;}
	Weapon_Val(id, index, flagset);}

////////////////////////////////////////////////////////////////
// Allocation

// If a given id is a valid weapon id.
bool Weapon_ValidId(int id) {
	return 0 <= id && id < WEAPON_DATA_COUNT;}

// If a given weapon id already exists.
bool Weapon_Exists(lweapon lweapons, eweapon eweapons, int id) {
	if (id < LWEAPON_MAX) {return LWeapon_Exists(lweapons, id);}
	return EWeapon_Exists(eweapons, id - LWEAPON_MAX);}

bool Weapon_IsLW(int id) {
	return id < LWEAPON_MAX;}

bool Weapon_IsEW(int id) {
	return id >= LWEAPON_MAX;}

// Creates a weapon. Returns the id.
int Weapon_Create(lweapon lws, eweapon ews) {
	int id;
	bool found = false;
	for (id = (G[Weapon_LastId] + 1) % WEAPON_DATA_COUNT;
			 id != G[Weapon_LastId];
			 id = (id + 1) % WEAPON_DATA_COUNT) {
		if (Weapon_Exists(lws, ews, id)) {continue;}
		// If it's previously allocated, wipe it clean.
		if (Weapon_Flag(id, WEAPON_F1, WEAPON_F1_ALLOC)) {
			Array_Fill(Weapon_Data, 0, id * WEAPON_DATA_SIZE, (id + 1) * WEAPON_DATA_SIZE);}
		// Mark as allocated.
		Weapon_Flag(id, WEAPON_F1, WEAPON_F1_ALLOC, true);
		// Save the last weapon id.
		G[Weapon_LastId] = id;
		found = true;
		break;}

	if (!found) {
		Weapon_Create_Message1();
		return -1;}

	// Actually create the weapon.
	if (id < LWEAPON_MAX) {
		lweapon o = Screen->CreateLWeapon(WEAPON_OBJECT_TYPE);
		LWeapon_Id(lws, o, id);
		o->NumFrames = 1;}
	else {
		eweapon o = Screen->CreateEWeapon(WEAPON_OBJECT_TYPE);
		EWeapon_Id(ews, o, id);
		o->NumFrames = 1;}

	return id;}

void Weapon_Create_Message1() {
	int a[]="ERROR: Weapon_Create: Out of weapon slots.";
	TraceS(a); TraceNL();}

////////////////////////////////////////////////////////////////
// Accessors

// Get the object id for a weapon.
int Weapon_ObjectId(int id) {
	int object_id = Weapon_Val(id, WEAPON_OBJECT_ID);
	if (object_id >= LWEAPON_MAX) {object_id -= LWEAPON_MAX;}
	return object_id;}

bool Weapon_HitLink(int id) {
	return Weapon_Flag(id, WEAPON_F1, WEAPON_F1_HIT_LINK);}

bool Weapon_HitEnemy(int id) {
	return Weapon_Flag(id, WEAPON_F1, WEAPON_F1_HIT_ENEMY);}

// Get the bounding box offset for the weapon.
int Weapon_Bounds(int id) {
	return WEAPON_DATA_SIZE * id + WEAPON_BOUNDS;}

void Weapon_Size(int id, int width, int height) {

}

int Weapon_Damage(int slot) {return Weapon_Val(slot, WEAPON_DAMAGE);}
void Weapon_Damage(int slot, int value) {Weapon_Val(slot, WEAPON_DAMAGE, value);}

int Weapon_Dir(lweapon lws, eweapon ews, int id) {
	if (Weapon_IsLW(id)) {
		lweapon o = Weapon_LWeapon(lws, id);
		return o->Dir;}
	if (Weapon_IsEW(id)) {
		eweapon o = Weapon_EWeapon(ews, id);
		return o->Dir;}}

int Weapon_Tile(lweapon lws, eweapon ews, int id) {
	if (Weapon_IsLW(id)) {
		lweapon o = Weapon_LWeapon(lws, id);
		return o->OriginalTile;}
	if (Weapon_IsEW(id)) {
		eweapon o = Weapon_EWeapon(ews, id);
		return o->OriginalTile;}}

void Weapon_Tile(lweapon lws, eweapon ews, int id, int tile) {
	if (Weapon_IsLW(id)) {
		lweapon o = Weapon_LWeapon(lws, id);
		o->OriginalTile = tile;}
	if (Weapon_IsEW(id)) {
		eweapon o = Weapon_EWeapon(ews, id);
		o->OriginalTile = tile;}}

// Get the source coordinates for a weapon.
// R[0] - the x position
// R[1] - the y position
void Weapon_SourceCoords(int id) {
	Weapon_SourceCoords(id, R);}
void Weapon_SourceCoords(int id, int returns) {
	// Get the edge towards the source.
	int dir = Weapon_Dir(id);
	if (Dir_Valid(dir)) {dir = OppositeDir(dir);}
	else {dir = -1;}

	int box[4];
	Box_Edge(Weapon_Data, Weapon_Bounds(id), dir, returns);}

////////////////////////////////////////////////////////////////
// Object Interface

// If a given lweapon object is an actual weapon.
bool Weapon_IsWeapon(lweapon o) {
	return WEAPON_OBJECT_TYPE == o->ID;}

// If a given eweapon object is an actual weapon.
bool Weapon_IsWeapon(eweapon o) {
	return WEAPON_OBJECT_TYPE == o->ID;}

// Get the weapon id of an lweapon.
int Weapon_Id(lweapon o) {
	return LWeapon_Id(o);}

// Get the weapon id of an eweapon.
int Weapon_Id(eweapon o) {
	return EWeapon_Id(o) + LWEAPON_MAX;}

// Get the lweapon for an id.
lweapon Weapon_LWeapon(lweapon lweapons, int id) {
	return lweapons[id];}

// Get the eweapon for an id.
eweapon Weapon_EWeapon(eweapon eweapons, int id) {
	return eweapons[id - LWEAPON_MAX];}

////////////////////////////////////////////////////////////////
// Active Script Calls

// Run through each weapon, checking for collisions.
void Weapon_Update() {
	for (int i = 1; i <= Screen->NumLWeapons(); ++i) {
		lweapon o = Screen->LoadLWeapon(i);
		if (!Weapon_IsWeapon(o)) {continue;}
		Weapon_Update(Weapon_Id(o));}
	for (int i = 1; i <= Screen->NumEWeapons(); ++i) {
		eweapon o = Screen->LoadEWeapon(i);
		if (!Weapon_IsWeapon(o)) {continue;}
		Weapon_Update(Weapon_Id(o));}}

// Check an individual weapon for collisions.
void Weapon_Update(int id) {
	if (Weapon_HitLink(id)) {
	}
	if (Weapon_HitEnemy(id)) {
	}
}
