////////////////////////////////////////////////////////////////
// Misc. Constants

// Misc index for npc's enemy id.
const int ENEMY_NMISC_ID = 2;

// D argument index for ffc scripts.
const int ENEMY_FFCD_ID = 0;

// Enemy attribute for its script.
const int ENEMY_NATTR_SCRIPT = 11;

////////////////////////////////////////////////////////////////
// Data Array

// Maximum number of enemies.
const int ENEMY_DATA_COUNT = 32;
// Space allocated for each enemy.
const int ENEMY_DATA_SIZE = 32;
// All enemy data.
int Enemy_Data[1024]; // size is previous two multiplied

//// First flag group.
const int ENEMY_F1 = 0;
// If this slot has been allocated.
const int ENEMY_F1_ALLOC = 1b;

// Index for enemy's npc id.
const int ENEMY_NPC_ID = 1;

// Indices for enemy position.
const int ENEMY_X = 2;
const int ENEMY_Y = 3;
const int ENEMY_Z = 4;

// Indices for enemy's life and damage.
const int ENEMY_LIFE = 5;
const int ENEMY_ATTACK = 6;
const int ENEMY_DEFENSE = 7;

// Indices for enemy state and arguments.
const int ENEMY_STATE = 8;
const int ENEMY_STATE_A = 9;
const int ENEMY_STATE_B = 10;
const int ENEMY_STATE_C = 11;

// Indices for enemy sense abilities.
const int ENEMY_SIGHT = 12;
const int ENEMY_SCENT = 13;

// Index for how long it's been since link has been seen.
// -1 is never seen / lost sight of completely.
const int ENEMY_LINK_TIME = 14;

// Indices for where the enemy thinks link is.
const int ENEMY_LINK_X = 15;
const int ENEMY_LINK_Y = 16;

////////////////////////////////////////////////////////////////
// States

const int ENEMY_STATE_NONE = 0;

//// Knockback
// Knockback state id.
const int ENEMY_STATE_KNOCKBACK = 1;
// State indices a through c.
const int ENEMY_KNOCKBACK_DX = 9;
const int ENEMY_KNOCKBACK_DY = 10;
const int ENEMY_KNOCKBACK_TIME = 11;

////////////////////////////////////////////////////////////////
// Basic Accessors

int Enemy_Val(int id, int index) {
	return Enemy_Data[id * ENEMY_DATA_SIZE + index];}

void Enemy_Val(int id, int index, int value) {
	Enemy_Data[id * ENEMY_DATA_SIZE + index] = value;}

void Enemy_ValAdd(int id, int index, int value) {
	Enemy_Data[id * ENEMY_DATA_SIZE + index] += value;}

bool Enemy_Flag(int id, int index, int key) {
	return Enemy_Val(id, index) & key;}

void Enemy_Flag(int id, int index, int key, bool value) {
	int flagset = Enemy_Val(id, index);
	if (value) {flagset |= key;}
	else {flagset &= ~key;}
	Enemy_Val(id, index, flagset);}

////////////////////////////////////////////////////////////////
// Allocation

// If a given id is a valid enemy id.
bool Enemy_ValidId(int id) {
	return 0 <= id && id < ENEMY_DATA_COUNT;}

// If a given enemy id is in use or not.
bool Enemy_IsAlloc(int id) {
	return Enemy_Flag(id, ENEMY_F1, ENEMY_F1_ALLOC);}

int Enemy_LastId = -1;
// Find an unused enemy id, mark it as used and return it.
int Enemy_Alloc() {
	int id = (Enemy_LastId + 1) % ENEMY_DATA_COUNT;
	while (id != Enemy_LastId) {
		if (!Enemy_IsAlloc(id)) {
			Enemy_LastId = id;
			// Initialize enemy to the default values.
			Array_Fill(Enemy_Data, 0, id * ENEMY_DATA_SIZE, (id + 1) * ENEMY_DATA_SIZE);
			Enemy_Flag(id, ENEMY_F1, ENEMY_F1_ALLOC, true);
			Enemy_Attack(id, Damage_Alloc());
			Enemy_Defense(id, Damage_Alloc());

			return id;}
		id = (id + 1) % ENEMY_DATA_COUNT;}

	int a[]="ERROR: Out of enemy slots. Suspected memory leak."; TraceS(a); TraceNL();
	return -1;}

// Free an enemy slot.
void Enemy_Free(int id) {
	Enemy_Flag(id, ENEMY_F1, ENEMY_F1_ALLOC, false);
	Damage_Free(Enemy_Attack(id));
	Damage_Free(Enemy_Defense(id));}

// Free all enemy slots.
void Enemy_FreeAll() {
	for (int id = 0; id < ENEMY_DATA_COUNT; ++id) {
		Enemy_Free(id);}}

////////////////////////////////////////////////////////////////
// Npc Interface

// Get the enemy id of an npc. -1 if none.
int Enemy_Id(npc o) {
	return o->Misc[ENEMY_NMISC_ID] - 1;}

////////////////////////////////////////////////////////////////
// Accessors

// Get the enemy's npc id.
int Enemy_NpcId(int id) {
	return Enemy_Val(id, ENEMY_NPC_ID);}

// Get the enemy's npc.
npc Enemy_Npc(int id) {
	int npc_id = Enemy_NpcId(id);
	if (-1 == npc_id) {
		int a[]="ERROR: No npc for enemy "; TraceS(a); Trace(id);}
	return Npc_Get(npc_id);}

//// Position
int Enemy_X(int id) {return Enemy_Val(id, ENEMY_X);}
void Enemy_X(int id, int value) {Enemy_Val(id, ENEMY_X, value);}
int Enemy_Y(int id) {return Enemy_Val(id, ENEMY_Y);}
void Enemy_Y(int id, int value) {Enemy_Val(id, ENEMY_Y, value);}
int Enemy_Z(int id) {return Enemy_Val(id, ENEMY_Z);}
void Enemy_Z(int id, int value) {Enemy_Val(id, ENEMY_Z, value);}

// Get the collision box for the enemy.
void Enemy_ReadBox(int id, int box) {
	int x = Enemy_X(id);
	int y = Enemy_Y(id);
	box[DIR_UP] = y + 4;
	box[DIR_DOWN] = y + 15;
	box[DIR_LEFT] = x + 2;
	box[DIR_RIGHT] = x + 13;}

// Set's the enemy's position based on a collision box.
void Enemy_WriteBox(int id, int box) {
	Enemy_X(id, box[DIR_LEFT] - 2);
	Enemy_Y(id, box[DIR_UP] - 4);}

int Enemy_Dir(int id) {
	npc o = Enemy_Npc(id);
	return o->Dir;}
void Enemy_Dir(int id, int value) {
	npc o = Enemy_Npc(id);
	o->Dir = value;}

int Enemy_CenterX(int id) {return Enemy_X(id) + 7.5;}
int Enemy_CenterY(int id) {return Enemy_Y(id) + 9.5;}

int Enemy_State(int id) {return Enemy_Val(id, ENEMY_STATE);}
void Enemy_State(int id, int value) {Enemy_Val(id, ENEMY_STATE, value);}

int Enemy_Life(int id) {return Enemy_Val(id, ENEMY_LIFE);}
void Enemy_Life(int id, int value) {Enemy_Val(id, ENEMY_LIFE, value);}
void Enemy_LifeAdd(int id, int value) {Enemy_ValAdd(id, ENEMY_LIFE, value);}


int Enemy_Attack(int id) {return Enemy_Val(id, ENEMY_ATTACK);}
void Enemy_Attack(int id, int value) {Enemy_Val(id, ENEMY_ATTACK, value);}
int Enemy_Defense(int id) {return Enemy_Val(id, ENEMY_DEFENSE);}
void Enemy_Defense(int id, int value) {Enemy_Val(id, ENEMY_DEFENSE, value);}

int Enemy_Sight(int id) {return Enemy_Val(id, ENEMY_SIGHT);}
void Enemy_Sight(int id, int value) {Enemy_Val(id, ENEMY_SIGHT, value);}
int Enemy_Scent(int id) {return Enemy_Val(id, ENEMY_SCENT);}
void Enemy_Scent(int id, int value) {Enemy_Val(id, ENEMY_SCENT, value);}

int Enemy_LinkX(int id) {return Enemy_Val(id, ENEMY_LINK_X);}
void Enemy_LinkX(int id, int value) {Enemy_Val(id, ENEMY_LINK_X, value);}
int Enemy_LinkY(int id) {return Enemy_Val(id, ENEMY_LINK_Y);}
void Enemy_LinkY(int id, int value) {Enemy_Val(id, ENEMY_LINK_Y, value);}
int Enemy_LinkTime(int id) {return Enemy_Val(id, ENEMY_LINK_TIME);}
void Enemy_LinkTime(int id, int value) {Enemy_Val(id, ENEMY_LINK_TIME, value);}

int Enemy_Speed(int id) {
	npc o = Enemy_Npc(id);
	return o->Step * 0.01;}

// Get the collision box for the enemy.
void Enemy_Box(int id, int ret_box) {
	int x = Enemy_X(id);
	int y = Enemy_Y(id);
	ret_box[DIR_UP] = y + 8;
	ret_box[DIR_DOWN] = y + 15;
	ret_box[DIR_LEFT] = x;
	ret_box[DIR_RIGHT] = x + 15;}

////////////////////////////////////////////////////////////////
// Active Script Calls

// Grabs unmanaged npcs.
void Enemy_Detect() {
	if (Screen_Changed) {Enemy_FreeAll();}

	for (int i = 1; i <= Screen->NumNPCs(); ++i) {
		npc o = Screen->LoadNPC(i);
		int id = Enemy_Id(o);
		// If it has an id, skip it.
		if (-1 != id) {continue;}

		if (DEBUG_ENEMY == Debug_Mode) {
			int a[]="Detected enemy!"; TraceS(a); TraceNL();}

		// First, check to see if the enemy has a script to run.
		int scr = o->Attributes[ENEMY_NATTR_SCRIPT];
		int ffc_index;
		if (scr != 0) {
			ffc_index = FFC_FindFree();
			// If there's no free ffc, kill self.
			if (-1 == ffc_index) {
				int a[]="ERROR: No free ffc. Destroying npc.";
				TraceS(a); TraceNL();
				Npc_Destroy(o);
				continue;}}

		// Create enemy.
		id = Enemy_Alloc();

		if (DEBUG_ENEMY == Debug_Mode) {
			int a[]="  Enemy id: "; TraceS(a); Trace(id);}

		Enemy_Val(id, ENEMY_NPC_ID, Npc_Id(i));
		Enemy_X(id, o->X);
		Enemy_Y(id, o->Y);
		Enemy_Z(id, o->Z);
		Enemy_Life(id, o->HP);
		Enemy_LinkTime(id, -1);

		// Mark enemy as in use.
		o->Misc[ENEMY_NMISC_ID] = id + 1;

		// No good place for this, so do it here.
		o->DrawYOffset = 0;

		// Now setup the script
		if (scr != 0) {
			ffc run = Screen->LoadFFC(ffc_index);
			run->Script = scr;
			run->InitD[ENEMY_FFCD_ID] = id;}}}

// Moves enemies appropriately.
void Enemy_Update() {
	for (int id = 0; id < ENEMY_DATA_COUNT; ++id) {
		if (!Enemy_IsAlloc(id)) {continue;}

		if (!Npc_Exists(Enemy_NpcId(id))) {
			Enemy_Free(id);
			continue;}

		// Update link knowledge.
		Enemy_SenseLink(id);

		// Do any specific state.
		int state = Enemy_State(id);
		if (ENEMY_STATE_KNOCKBACK == state) {
			Enemy_Move(id,
								 Enemy_Val(id, ENEMY_KNOCKBACK_DX),
								 Enemy_Val(id, ENEMY_KNOCKBACK_DY));
			int timer = Enemy_Val(id, ENEMY_KNOCKBACK_TIME);
			timer -= 1;
			if (timer > 0) {
				Enemy_Val(id, ENEMY_KNOCKBACK_TIME, timer);}
			else {
				Enemy_State(id, ENEMY_STATE_NONE);}}

		// Update the npc.
		npc o = Enemy_Npc(id);
		o->X = Enemy_X(id);
		o->Y = Enemy_Y(id);
		o->Z = Enemy_Z(id);

		if (Debug_Boxes) {
			int box[4];
			Enemy_ReadBox(id, box);
			Box_Draw(box, 7, 23, OP_OPAQUE);}}}

////////////////////////////////////////////////////////////////
// Global Script Calls

void Enemy_Init() {Enemy_FreeAll();}
void Enemy_Continue() {Enemy_FreeAll();}

////////////////////////////////////////////////////////////////
// Senses

// Marks link as spotted.
void Enemy_LinkSpotted(int id) {
	Enemy_LinkX(id, Link_CenterX());
	Enemy_LinkY(id, Link_CenterY());
	Enemy_LinkTime(id, 0);}

// Try to sense link.
void Enemy_SenseLink(int id) {
	int time = Enemy_LinkTime(id);
	if (time >= 0) {
		Enemy_LinkTime(id, time + 1);}

	int x1 = Enemy_CenterX(id);
	int y1 = Enemy_CenterY(id);
	int x2 = Link_CenterX();
	int y2 = Link_CenterY();

	int sight = Enemy_Sight(id);
	if (sight > 0) {
		int angle = Angle(x1, y1, x2, y2);
		int delta = angle - Dir_Degrees(Enemy_Dir(id));
		delta = Abs(delta) % 360;
		if (delta > 180) {delta = 360 - delta;}
		if (delta <= sight * 0.5) {
			if (Terrain_Line(x1, y1, x2, y2) & TERRAIN_SEE) {
				Enemy_LinkSpotted(id);
				return;}}}

	int scent = Enemy_Scent(id);
	if (scent > 0 && Distance(x1, y1, x2, y2) < scent) {
		Enemy_LinkSpotted(id);
		return;}}

////////////////////////////////////////////////////////////////
// Damage

void Enemy_TakeDamage(int id, int damage, int srcX, int srcY) {
	int tmp_damage[4];
	Damage_Read(tmp_damage, damage);
	Damage_SubLocal(tmp_damage, Enemy_Defense(id));

	if (tmp_damage[DAMAGE_KNOCKBACK] > 0) {
		int angle = Angle(srcX, srcY, Enemy_CenterX(id), Enemy_CenterY(id));
		Enemy_Knockback(id, tmp_damage[DAMAGE_KNOCKBACK], angle);}

	int total_damage = 0;
	for (int dt = 1; dt < DAMAGE_TYPE_COUNT; ++dt) {
		total_damage += tmp_damage[dt];}

	int life = Enemy_Life(id);
	life -= total_damage;
	Enemy_Life(id, life);

	if (life <= 0) {
		npc o = Enemy_Npc(id);
		Weapon_Free(Weapon_Id(o));
		Npc_Destroy(o);
		Enemy_Free(id);}}

////////////////////////////////////////////////////////////////
// Use

void Enemy_Knockback(int id, int power, int angle) {
	Enemy_State(id, ENEMY_STATE_KNOCKBACK);
	Enemy_Val(id, ENEMY_KNOCKBACK_TIME, 6);
	Enemy_Val(id, ENEMY_KNOCKBACK_DX, power * Cos(angle));
	Enemy_Val(id, ENEMY_KNOCKBACK_DY, power * Sin(angle));}

// Move the enemy by the given amount. Returns the distance traveled.
int Enemy_Move(int id, int distance, int angle) {
	int box[4];
	Enemy_ReadBox(id, box);
	distance = Terrain_BoxSlide(box, distance, angle, TERRAIN_WALK | TERRAIN_ONSCREEN);
	Enemy_WriteBox(id, box);
	return distance;}

// Make the enemy walk towards the given coordinates.
// id - the enemy id
// x, y - where the enemy is trying to move its center to
int Enemy_Walk(int id, int x, int y) {
	int start_x = Enemy_CenterX(id);
	int start_y = Enemy_CenterY(id);
	int dx = x - start_x;
	int dy = y - start_y;
	int distance = Min(Enemy_Speed(id), Sqrt(dx*dx + dy*dy));
	int angle = Angle(dx, dy);

	int box[4];
	Enemy_ReadBox(id, box);
	distance = Terrain_BoxSlide(box, distance, angle, TERRAIN_WALK | TERRAIN_ONSCREEN);
	Enemy_WriteBox(id, box);

	int end_x = Enemy_CenterX(id);
	int end_y = Enemy_CenterY(id);
	Enemy_Dir(id, Dir_Major(end_x - start_x, end_y - start_y));

	return distance;}

////////////////////////////////////////////////////////////////
// Wandering

const int ENEMY_WANDER_DIST = 0;
const int ENEMY_WANDER_ANGLE = 1;
const int ENEMY_WANDER_WAIT = 2;

// Wander around. Takes a 3 element data array to keep track of where we're
// going.
void Enemy_Wander(int enemy_id, int data) {
	// If we're stopped pick a new direction. And wait for a while.
	if (data[ENEMY_WANDER_DIST] <= 0) {
		data[ENEMY_WANDER_DIST] = Rand(100) + 100;
		data[ENEMY_WANDER_ANGLE] = Rand(361) - 180;
		data[ENEMY_WANDER_WAIT] = Rand(120) - 60;
		return;}

	// Rest
	if (data[ENEMY_WANDER_WAIT] > 0) {
		--data[ENEMY_WANDER_WAIT];
		return;}

	// Move.
	int dx = Cos(data[ENEMY_WANDER_ANGLE]) * data[ENEMY_WANDER_DIST];
	int dy = Sin(data[ENEMY_WANDER_ANGLE]) * data[ENEMY_WANDER_DIST];
	int x = Enemy_CenterX(enemy_id) + dx;
	int y = Enemy_CenterY(enemy_id) + dy;
	int box[4];
	Enemy_ReadBox(enemy_id, box);
	int distance = Enemy_Walk(enemy_id, x, y);

	// If we can no longer move in the current direction, pick a new direction
	// (next round).
	if (distance <= 0) {
		data[ENEMY_WANDER_DIST] = 0;
		return;}

	Enemy_Dir(enemy_id, Dir_Major(dx, dy));
	data[ENEMY_WANDER_DIST] -= distance;}
